package enhanced

import (
	"encoding/json"
	"fmt"
	"log"
	"strings"

	"github.com/ThatsRight-ItsTJ/Your-PaL-MoE/pkg/selection"
)

// EnhancedSystemV3 integrates dynamic model discovery with the enhanced system
type EnhancedSystemV3 struct {
	providers     []selection.Provider
	selector      *selection.EnhancedAdaptiveSelector
	modelLoader   *selection.DynamicModelLoader
	yamlLoader    *selection.YAMLProviderLoader
}

// NewEnhancedSystemV3 creates a new enhanced system with full dynamic model support
func NewEnhancedSystemV3(csvPath string, yamlDir string) (*EnhancedSystemV3, error) {
	log.Println("üöÄ Initializing Enhanced System v3.0 with dynamic model discovery...")
	
	// Try to load providers with dynamic model discovery
	var providers []selection.Provider
	var err error
	
	// First try CSV with dynamic model discovery
	providers, err = selection.LoadProvidersFromCSVWithDynamicModels(csvPath)
	if err != nil {
		return nil, fmt.Errorf("failed to load providers: %w", err)
	}
	
	// Create enhanced system
	system := &EnhancedSystemV3{
		providers:   providers,
		selector:    selection.NewEnhancedAdaptiveSelector(providers),
		modelLoader: selection.NewDynamicModelLoader(),
		yamlLoader:  selection.NewYAMLProviderLoader(),
	}
	
	log.Printf("‚úÖ Enhanced System v3.0 initialized with %d providers", len(providers))
	return system, nil
}

// ProcessRequest handles a request using enhanced provider selection with dynamic models
func (es *EnhancedSystemV3) ProcessRequest(request string) (*ProcessResponse, error) {
	log.Printf("üöÄ Processing request with Enhanced System v3.0: %.100s...", request)

	// Select the best provider using enhanced model database
	provider, confidence, err := es.selector.SelectProvider(request)
	if err != nil {
		return nil, fmt.Errorf("provider selection failed: %w", err)
	}

	log.Printf("‚úÖ Enhanced selection: %s (confidence: %.2f%%) - Models: %v", 
		provider.Name, confidence*100, provider.Models)

	// Get detailed analysis for logging
	analysis := es.selector.AnalyzeRequest(request)
	if analysisJSON, err := json.MarshalIndent(analysis, "", "  "); err == nil {
		log.Printf("üìä Detailed analysis:\n%s", string(analysisJSON))
	}

	// Generate response
	response := es.generateResponse(provider, request, confidence)

	return response, nil
}

// generateResponse creates a mock response from the selected provider
func (es *EnhancedSystemV3) generateResponse(provider *selection.Provider, request string, confidence float64) *ProcessResponse {
	taskType := es.selector.GetDetector().DetectTaskType(request)
	
	var responseContent string
	var responseType string

	switch taskType {
	case selection.TaskTypeImage:
		responseContent = fmt.Sprintf("üé® [MOCK IMAGE GENERATION] Generated image using %s\nAvailable models: %v\nSelected based on image generation capabilities", 
			provider.Name, provider.Models)
		responseType = "image_generation"
		
	case selection.TaskTypeCode:
		responseContent = fmt.Sprintf("üíª [MOCK CODE GENERATION] Generated code using %s\nAvailable models: %v\n\n```python\n# Example code generated by %s\ndef hello_world():\n    print('Hello from %s with dynamic models!')\n```", 
			provider.Name, provider.Models, provider.Name, provider.Name)
		responseType = "code_generation"
		
	case selection.TaskTypeAudio:
		responseContent = fmt.Sprintf("üéµ [MOCK AUDIO PROCESSING] Processed audio using %s\nAvailable models: %v", 
			provider.Name, provider.Models)
		responseType = "audio_processing"
		
	case selection.TaskTypeVideo:
		responseContent = fmt.Sprintf("üé¨ [MOCK VIDEO PROCESSING] Processed video using %s\nAvailable models: %v", 
			provider.Name, provider.Models)
		responseType = "video_processing"
		
	case selection.TaskTypeMultimodal:
		responseContent = fmt.Sprintf("üîÑ [MOCK MULTIMODAL] Processed multimodal request using %s\nAvailable models: %v", 
			provider.Name, provider.Models)
		responseType = "multimodal"
		
	default: // TaskTypeText
		responseContent = fmt.Sprintf("üìù [MOCK TEXT GENERATION] Generated text response using %s\nAvailable models: %v\n\nThis is a mock response to: %s\n\nNote: Models were loaded dynamically from provider endpoints where available.", 
			provider.Name, provider.Models, request)
		responseType = "text_generation"
	}

	return &ProcessResponse{
		Content:    responseContent,
		Provider:   provider.Name,
		Models:     provider.Models,
		Confidence: confidence,
		Metadata: map[string]interface{}{
			"task_type":        string(taskType),
			"response_type":    responseType,
			"selection_method": "enhanced_v3_dynamic_models",
			"provider_url":     provider.BaseURL,
			"model_count":      len(provider.Models),
			"dynamic_loading":  es.hasDynamicModels(provider),
		},
	}
}

// hasDynamicModels checks if a provider uses dynamic model loading
func (es *EnhancedSystemV3) hasDynamicModels(provider *selection.Provider) bool {
	for _, model := range provider.Models {
		if strings.HasPrefix(model, "/") || strings.HasPrefix(model, "http://") || strings.HasPrefix(model, "https://") {
			return true
		}
	}
	return false
}

// RefreshAllModels refreshes models for all providers
func (es *EnhancedSystemV3) RefreshAllModels() error {
	log.Println("üîÑ Refreshing all provider models...")
	
	// Clear caches
	es.modelLoader.ClearCache()
	es.yamlLoader.RefreshAllModels()
	
	// Refresh CSV-based providers
	err := selection.RefreshProviderModelsFromCSV(es.providers)
	if err != nil {
		return fmt.Errorf("failed to refresh CSV provider models: %w", err)
	}
	
	// Update the selector with refreshed providers
	es.selector = selection.NewEnhancedAdaptiveSelector(es.providers)
	
	log.Println("‚úÖ All provider models refreshed successfully")
	return nil
}

// GetProviders returns the list of providers
func (es *EnhancedSystemV3) GetProviders() []selection.Provider {
	return es.providers
}

// GetProviderCapabilities returns detailed capabilities for all providers
func (es *EnhancedSystemV3) GetProviderCapabilities() map[string]selection.ProviderCapabilities {
	return es.selector.GetProviderCapabilities()
}

// GetDetailedModelCapabilities returns per-model capabilities
func (es *EnhancedSystemV3) GetDetailedModelCapabilities() map[string]map[string]selection.ModelCapabilities {
	return es.selector.GetDetailedModelCapabilities()
}

// AnalyzeRequest provides detailed analysis of provider selection
func (es *EnhancedSystemV3) AnalyzeRequest(request string) map[string]interface{} {
	analysis := es.selector.AnalyzeRequest(request)
	
	// Add dynamic loading information
	analysis["dynamic_loading_stats"] = es.getDynamicLoadingStats()
	
	return analysis
}

// getDynamicLoadingStats returns statistics about dynamic model loading
func (es *EnhancedSystemV3) getDynamicLoadingStats() map[string]interface{} {
	stats := map[string]interface{}{
		"providers_with_dynamic_models": 0,
		"total_dynamic_endpoints":       0,
		"cache_stats":                   es.modelLoader.GetCacheStats(),
	}
	
	dynamicProviders := 0
	totalEndpoints := 0
	
	for _, provider := range es.providers {
		hasDynamic := false
		endpoints := 0
		
		for _, model := range provider.Models {
			if strings.HasPrefix(model, "/") || strings.HasPrefix(model, "http://") || strings.HasPrefix(model, "https://") {
				hasDynamic = true
				endpoints++
			}
		}
		
		if hasDynamic {
			dynamicProviders++
		}
		totalEndpoints += endpoints
	}
	
	stats["providers_with_dynamic_models"] = dynamicProviders
	stats["total_dynamic_endpoints"] = totalEndpoints
	
	return stats
}

// GetSystemInfo returns comprehensive system information
func (es *EnhancedSystemV3) GetSystemInfo() map[string]interface{} {
	providerCount := len(es.providers)
	totalModels := 0
	dynamicProviders := 0
	
	for _, provider := range es.providers {
		totalModels += len(provider.Models)
		if es.hasDynamicModels(&provider) {
			dynamicProviders++
		}
	}
	
	return map[string]interface{}{
		"version":              "3.0.0-dynamic-models",
		"provider_count":       providerCount,
		"dynamic_providers":    dynamicProviders,
		"total_models":         totalModels,
		"capabilities":         es.GetProviderCapabilities(),
		"dynamic_loading_stats": es.getDynamicLoadingStats(),
		"selection_method":     "enhanced_adaptive_with_dynamic_models",
		"features": []string{
			"dynamic_model_discovery",
			"csv_endpoint_integration", 
			"yaml_configuration_support",
			"model_database_integration",
			"huggingface_api_support",
			"per_model_capability_analysis",
			"enhanced_task_detection",
			"weighted_provider_scoring",
			"capability_validation",
			"real_time_model_refresh",
		},
	}
}

// ValidateProviders checks if all providers have valid configurations
func (es *EnhancedSystemV3) ValidateProviders() map[string][]string {
	issues := make(map[string][]string)
	
	for _, provider := range es.providers {
		var providerIssues []string
		
		// Check basic provider configuration
		if provider.Name == "" {
			providerIssues = append(providerIssues, "Provider name is empty")
		}
		
		if provider.BaseURL == "" {
			providerIssues = append(providerIssues, "Provider BaseURL is empty")
		}
		
		if len(provider.Models) == 0 {
			providerIssues = append(providerIssues, "Provider has no models configured")
		}
		
		// Check for dynamic model endpoints
		for _, model := range provider.Models {
			if strings.HasPrefix(model, "/") || strings.HasPrefix(model, "http://") || strings.HasPrefix(model, "https://") {
				// Try to validate the endpoint
				var modelURL string
				if strings.HasPrefix(model, "/") {
					baseURL := strings.TrimSuffix(provider.BaseURL, "/")
					modelURL = baseURL + model
				} else {
					modelURL = model
				}
				
				// Test if we can fetch from this endpoint (non-blocking)
				_, err := es.modelLoader.LoadModelsFromSource(modelURL)
				if err != nil {
					providerIssues = append(providerIssues, 
						fmt.Sprintf("Dynamic model endpoint unreachable: %s (%v)", modelURL, err))
				}
			}
		}
		
		// Validate detected capabilities
		capabilities := es.selector.GetProviderCapabilities()[provider.Name]
		if valid, warnings := es.selector.GetDetector().ValidateCapabilities(capabilities); !valid {
			providerIssues = append(providerIssues, warnings...)
		}
		
		if len(providerIssues) > 0 {
			issues[provider.Name] = providerIssues
		}
	}
	
	return issues
}

// SetSelectionWeights allows customizing provider selection criteria
func (es *EnhancedSystemV3) SetSelectionWeights(weights selection.SelectionWeights) {
	es.selector.SetSelectionWeights(weights)
	log.Printf("‚öñÔ∏è Selection weights updated: %+v", weights)
}