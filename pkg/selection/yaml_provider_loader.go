package selection

import (
	"fmt"
	"io/ioutil"
	"log"
	"path/filepath"
	"strings"

	"gopkg.in/yaml.v2"
)

// YAMLProviderConfig represents the YAML configuration structure
type YAMLProviderConfig struct {
	Provider struct {
		Name    string `yaml:"name"`
		Tier    string `yaml:"tier"`
		BaseURL string `yaml:"base_url"`
		APIKey  string `yaml:"api_key"`
	} `yaml:"provider"`
	
	Models struct {
		Source         string `yaml:"source"`
		DynamicLoading bool   `yaml:"dynamic_loading"`
		StaticList     string `yaml:"static_list,omitempty"`
	} `yaml:"models"`
	
	Configuration struct {
		Timeout    string `yaml:"timeout"`
		MaxRetries int    `yaml:"max_retries"`
	} `yaml:"configuration"`
	
	RateLimiting struct {
		Enabled           bool `yaml:"enabled"`
		RequestsPerMinute int  `yaml:"requests_per_minute"`
	} `yaml:"rate_limiting"`
	
	Capabilities []string `yaml:"capabilities"`
	
	Metadata struct {
		Description   string `yaml:"description"`
		AutoGenerated bool   `yaml:"auto_generated"`
		CSVSource     string `yaml:"csv_source"`
		GeneratedAt   string `yaml:"generated_at"`
	} `yaml:"metadata"`
}

// YAMLProviderLoader loads providers from YAML files with dynamic model discovery
type YAMLProviderLoader struct {
	modelLoader *DynamicModelLoader
}

// NewYAMLProviderLoader creates a new YAML provider loader
func NewYAMLProviderLoader() *YAMLProviderLoader {
	return &YAMLProviderLoader{
		modelLoader: NewDynamicModelLoader(),
	}
}

// LoadProvidersFromYAMLDir loads all providers from YAML files in a directory
func (ypl *YAMLProviderLoader) LoadProvidersFromYAMLDir(dirPath string) ([]Provider, error) {
	log.Printf("üîç Loading providers from YAML directory: %s", dirPath)
	
	files, err := filepath.Glob(filepath.Join(dirPath, "*.yaml"))
	if err != nil {
		return nil, fmt.Errorf("failed to find YAML files: %w", err)
	}
	
	yamlFiles, err := filepath.Glob(filepath.Join(dirPath, "*.yml"))
	if err == nil {
		files = append(files, yamlFiles...)
	}
	
	if len(files) == 0 {
		return nil, fmt.Errorf("no YAML files found in %s", dirPath)
	}
	
	var providers []Provider
	
	for _, file := range files {
		provider, err := ypl.LoadProviderFromYAML(file)
		if err != nil {
			log.Printf("‚ö†Ô∏è  Failed to load provider from %s: %v", file, err)
			continue
		}
		
		providers = append(providers, *provider)
		log.Printf("‚úÖ Loaded provider: %s (%d models)", provider.Name, len(provider.Models))
	}
	
	log.Printf("üìã Successfully loaded %d providers from YAML files", len(providers))
	return providers, nil
}

// LoadProviderFromYAML loads a single provider from a YAML file
func (ypl *YAMLProviderLoader) LoadProviderFromYAML(filePath string) (*Provider, error) {
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read YAML file %s: %w", filePath, err)
	}
	
	var config YAMLProviderConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse YAML file %s: %w", filePath, err)
	}
	
	// Load models dynamically or statically
	var models []string
	
	if config.Models.DynamicLoading && config.Models.Source != "" {
		log.Printf("üåê Loading models dynamically for %s from: %s", config.Provider.Name, config.Models.Source)
		
		dynamicModels, err := ypl.modelLoader.LoadModelsFromSource(config.Models.Source)
		if err != nil {
			log.Printf("‚ö†Ô∏è  Failed to load models dynamically for %s: %v", config.Provider.Name, err)
			
			// Fallback to static list if available
			if config.Models.StaticList != "" {
				log.Printf("üîÑ Falling back to static model list for %s", config.Provider.Name)
				models = ypl.modelLoader.parseStaticModels(config.Models.StaticList)
			} else {
				// Use default models based on capabilities
				models = ypl.getDefaultModelsForCapabilities(config.Capabilities, config.Provider.Name)
			}
		} else {
			models = dynamicModels
		}
	} else if config.Models.StaticList != "" {
		log.Printf("üìã Using static model list for %s", config.Provider.Name)
		models = ypl.modelLoader.parseStaticModels(config.Models.StaticList)
	} else {
		// Use default models based on capabilities
		models = ypl.getDefaultModelsForCapabilities(config.Capabilities, config.Provider.Name)
	}
	
	if len(models) == 0 {
		log.Printf("‚ö†Ô∏è  No models found for provider %s, using default", config.Provider.Name)
		models = []string{"default"}
	}
	
	provider := &Provider{
		Name:    config.Provider.Name,
		BaseURL: config.Provider.BaseURL,
		Models:  models,
	}
	
	return provider, nil
}

// getDefaultModelsForCapabilities returns default models based on capabilities
func (ypl *YAMLProviderLoader) getDefaultModelsForCapabilities(capabilities []string, providerName string) []string {
	// Create reasonable defaults based on capabilities
	var models []string
	
	hasChat := false
	hasImage := false
	hasCode := false
	
	for _, cap := range capabilities {
		switch strings.ToLower(cap) {
		case "chat", "text", "completion":
			hasChat = true
		case "image", "vision", "image_generation":
			hasImage = true
		case "code", "coding", "programming":
			hasCode = true
		}
	}
	
	// Generate reasonable model names based on provider and capabilities
	providerLower := strings.ToLower(providerName)
	
	if hasChat {
		if strings.Contains(providerLower, "openai") {
			models = append(models, "gpt-3.5-turbo", "gpt-4")
		} else if strings.Contains(providerLower, "anthropic") {
			models = append(models, "claude-3-sonnet", "claude-3-haiku")
		} else if strings.Contains(providerLower, "google") {
			models = append(models, "gemini-pro", "gemini-pro-vision")
		} else {
			models = append(models, "chat-model")
		}
	}
	
	if hasImage {
		if strings.Contains(providerLower, "openai") {
			models = append(models, "dall-e-3", "dall-e-2")
		} else if strings.Contains(providerLower, "stability") {
			models = append(models, "stable-diffusion-xl")
		} else {
			models = append(models, "image-model")
		}
	}
	
	if hasCode {
		if strings.Contains(providerLower, "openai") {
			models = append(models, "gpt-4-turbo")
		} else {
			models = append(models, "code-model")
		}
	}
	
	if len(models) == 0 {
		models = []string{"default-model"}
	}
	
	return models
}

// RefreshAllModels refreshes models for all cached providers
func (ypl *YAMLProviderLoader) RefreshAllModels() {
	ypl.modelLoader.ClearCache()
	log.Println("üîÑ All provider model caches refreshed")
}

// GetCacheStats returns model loading cache statistics
func (ypl *YAMLProviderLoader) GetCacheStats() map[string]interface{} {
	return ypl.modelLoader.GetCacheStats()
}